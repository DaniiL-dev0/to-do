/******************************************************************************************************************************************
[x]          - признак наличия метода/поля в коде
{x}          - признак наличия покрывающего теста для того или иного метода/поля
*опционально - обязательно к реализации, но использование класса возможно и без этого поля

    Класс "Задача" - Task. Используется в интерфейсах "Еженедельное планирование" и "Проект"
    Поля класса:
    //NOTE -  v 1.0
[x]  _name         : (string)                             -название задачи
[x]  _description  : (string)                             -описание задачи (опционально)
[x]  _creation_date: (пользовательский тип data_t)        -дата создания   (инициализация при создании объекта класса)
[x]  _ending_date  : (пользовательский тип data_t)        -дата окончания  (опционально)
[x]  _status       : (bool)                               -готова ли задача

    Методы класса:
    //NOTE -  v 1.0
        Возможны несколько видов конструкторов:
[x]{x}   -c заполнением всех полей(некоторые поля, могут быть не проинициализированными, важно учитывать!)
[x]{x}   получить значение/изменить _name
[x]{x}   получить значение/изменить _description
[x]{x}   добавить/убрать дату окончания
[x]{x}   выставить/убрать признак готовности задачи

    update: (то есть возможно добавление в след версии)
        1) Возможность прикреплять теги к пунктам. Тогда такой тег относится и к пункту, и к задаче, 
        чтобы найти какие пункты соответствуют нужному тегу
        2) Наличие подзадач и работа с ними
        3) Поиск
*******************************************************************************************************************************************/
#pragma once

#include <string>
#include <cstring>

#include "lib.h"
#include "lib/classes/task.h"

namespace pos
{

class Task : public lib::Task
{
private:
    std::string _name,
                _description;
    STATUS _status;

    data_t _creation_date{},
           _ending_date  {};

public:

};


}


inline bool operator<(const pos::Task &lhs, const pos::Task &rhs)
{
    return std::lexicographical_compare(lhs.name().begin(), lhs.name().end(), rhs.name().begin(), rhs.name().end());
}